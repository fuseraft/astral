#!/usr/bin/astral

# This ðŸš€ script is for experimentation.

input = "hello"

# All variables wrap modulo 2^32 when calculating:
s = [0] * 64
K = [0] * 64

# s specifies the per-round shift amounts
s[ 0:15] = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22]
s[16:31] = [5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20]
s[32:47] = [4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23]
s[48:63] = [6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21]

# Use binary integer part of the sines of integers (Radians) as constants:
for i in [0..63] do
  K[i] = __floor__(232 * __abs__(__sin__(i + 1)))
end

a0 = 0x67452301   # A
b0 = 0xefcdab89   # B
c0 = 0x98badcfe   # C
d0 = 0x10325476   # D

message = [104, 101, 108, 108, 111]
#message << 

/#
std::vector<uint8_t> paddedMessage(input.begin(), input.end());

    // Append 0x80 (128 in decimal, 10000000 in binary) to the message
    paddedMessage.push_back(0x80);

    // Pad with zeros until the message length in bytes is 56 mod 64
    while (paddedMessage.size() % 64 != 56) {
        paddedMessage.push_back(0x00);
    }

    // Original message length in bits, mod 2^64
    uint64_t originalBitLength = static_cast<uint64_t>(input.size()) * 8;

    // Append the length in bits at the end of the buffer.
    for (int i = 0; i < 8; ++i) {
        paddedMessage.push_back(static_cast<uint8_t>(originalBitLength >> (i * 8)));
    }

    return paddedMessage;
    #/

println "Done"

/#

// Pre-processing: adding a single 1 bit
append "1" bit to message<    
 // Notice: the input bytes are considered as bit strings,
 //  where the first bit is the most significant bit of the byte.[53]

// Pre-processing: padding with zeros
append "0" bit until message length in bits â‰¡ 448 (mod 512)

// Notice: the two padding steps above are implemented in a simpler way
  //  in implementations that only work with complete bytes: append 0x80
  //  and pad with 0x00 bytes so that the message length in bytes â‰¡ 56 (mod 64).

append original length in bits mod 264 to message

// Process the message in successive 512-bit chunks:
for each 512-bit chunk of padded message do
    break chunk into sixteen 32-bit words M[j], 0 â‰¤ j â‰¤ 15
    // Initialize hash value for this chunk:
    var int A := a0
    var int B := b0
    var int C := c0
    var int D := d0
    // Main loop:
    for i from 0 to 63 do
        var int F, g
        if 0 â‰¤ i â‰¤ 15 then
            F := (B and C) or ((not B) and D)
            g := i
        else if 16 â‰¤ i â‰¤ 31 then
            F := (D and B) or ((not D) and C)
            g := (5Ã—i + 1) mod 16
        else if 32 â‰¤ i â‰¤ 47 then
            F := B xor C xor D
            g := (3Ã—i + 5) mod 16
        else if 48 â‰¤ i â‰¤ 63 then
            F := C xor (B or (not D))
            g := (7Ã—i) mod 16
        // Be wary of the below definitions of a,b,c,d
        F := F + A + K[i] + M[g]  // M[g] must be a 32-bit block
        A := D
        D := C
        C := B
        B := B + leftrotate(F, s[i])
    end for
    // Add this chunk's hash to result so far:
    a0 := a0 + A
    b0 := b0 + B
    c0 := c0 + C
    d0 := d0 + D
end for

var char digest[16] := a0 append b0 append c0 append d0
#/